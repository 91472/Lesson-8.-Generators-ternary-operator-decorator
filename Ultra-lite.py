# Урок: Генераторы, тернарные операторы, исключения, декораторы
# Задание Ultra Lite:
# 1. Написать свой генератор последовательностей, свой тернарный оператор
# 2. Написать свой декоратор


# Выполнение задания Ultra Lite:
# 1. Написать свой генератор последовательностей, свой тернарный оператор
#Создадим генератор последовательности списка, вывод на экран генератором последовательности, словаря и множества:
gen_list_1 = [i for i in range(-10, 11) if i > 0] #список
print('Создание списка генератором последовательности:\n', gen_list_1, '\nтип объекта: ', type(gen_list_1), sep = '')
print('\nВывод на экран через генератор последовательности:')
gen_list_2 = [print(i,'**',j, '=', i**j) for i,j in enumerate(gen_list_1) if i > 5] #вывод на экран генератором последовательности
gen_dict = {i: j for i,j in enumerate(gen_list_1)} #словарь
print('\nСоздание словаря генератором последовательности:\n', gen_dict, '\nТип объекта: ', type(gen_dict), sep = '')
gen_set = {i for i,j in enumerate(gen_list_1)} #множество
print('\nСоздание множества генератором последовательности:\n', gen_set, '\nТип объекта: ', type(gen_set), sep = '')

#Создадим тернарный оператор внутри генератора последовательностей (если число четное, оставить, если нет, то заменить на символ *):
gen_ternary = [i if i%2 == 0 else '*' for i in range(1, 10)]
print('\nИспользование тернарного оператора совместно с генератором последовательности:\n', gen_ternary, sep = '')


# 2. Написать свой декоратор
#Создадим декоратор выводящий до вызова функции на экран кортеж неименованных параметров и словарь именованных параметров функции,
#И после вызова функции выводится текущая дата и время

import datetime #импортируем бидлиотеку работ с датой и временем
def args_time(f): #создаем декоратор
    def wrapper(*args, **kwargs): #обертка функции которая подается на декоратор
        print('\nКортеж из неименованных параметров: ', args, '\nСловарь из именованных параметров: ', kwargs)
        f(*args, **kwargs) #вызов функции
        print('Дата и время: ', datetime.datetime.today())
    return wrapper #декоратор возвращает вызов функции-обертки

#Создадим произвольную простую функцию, для которой применем этот декоратор:
@args_time #применение декоратора
def fun(*args, **kwargs):
    print('Списки значений именованных и неименованных параметров: ', [i for i in args], [i for i in kwargs.values()]) #функция выводит два списка - первый с неименованными параметрами, второй- со значеними именованных параметров

#вызовем функцию fun с произвольным набором параметров:
fun(10, 1, 2, 3, -1, True, a = 0, b = 10, c = 45, d = False)