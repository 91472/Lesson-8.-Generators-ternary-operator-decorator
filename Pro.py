# Урок: Генераторы, тернарные операторы, исключения, декораторы
# Задание Pro:
#1. Выполнить задание уровня light
#2. Написать декоратор, замеряющий объем оперативной памяти, потребляемый декорируемой функцией.
#3.4. Сравнить объем оперативной памяти для функции создания генератора и
#функции создания списка с элементами: натуральные числа от 1 до 1000000.


# Выполнение задания Pro:
#1. Задание уровня light выполнено: https://github.com/91472/Lesson-8.-Generators-ternary-operator-decorator/blob/b27d067d9664a82f33280712bc93982f29d58ca1/Lite.py

#2. Написать декоратор, замеряющий объем оперативной памяти, потребляемый декорируемой функцией.
import os #библиотека для работы с ОС
import psutil #библиотека для работы с процессами (информация о запущенных процессах, использование системы)

def rss(f): #создем функцию-декоратор для замера объема памяти RAM потребляемой декорируемой функцией
    def wrapper(*args, **kwargs):
# методом Process модуля psutil создаем объект, содержащий стат.информацию о текущем процессе
#PID-идентификатор текущего процесса берем методом getpid обращаясь к модулю os: os.getpid()
        proc = psutil.Process(os.getpid())
#применяем метод memory_info() к нашему объекту proc для извлечения информации о заполнении оперативной памяти
# на текущий момент, из всего кортежа os.getpid() берем только rss (RAM) в байтах, делим на 1000000 для Мб:
        rss_before = proc.memory_info().rss/1000000
        fun = f(*args, **kwargs) #присвоение декорируемой функции
        proc = psutil.Process(os.getpid())
        rss_after = proc.memory_info().rss/1000000 #объем задействованной RAM после вызова и исполнения функции f
        rss = round((rss_after - rss_before), 3)
        return rss
    return wrapper #функция-декоратор возвращает объем потребляемой памяти в Мб

#3.4. Сравнить объем оперативной памяти для функции создания генератора и
#функции создания списка с элементами: натуральные числа от 1 до 1000000.

#Создадим функцию-генератор и функцию-генератор последовательности для натуральных чисел от 1 до 1000000

#функция-генератор:
def gen(num):
    for i in range(1, num + 1):
        yield i
#функция-генератор списка:
def gen_list(num):
    return list(i for i in range(1, num+1))


#применим к созданным функциям выше созданный декоратор:
@rss
def gen(num):
    for i in range(1, num+1):
        yield i

@rss
def gen_list(num):
    return list(i for i in range(1, num+1))

print('Объем оперативной памяти потребляемый генератором, Мб:', gen(1000000)) #вызов функции с декоратором
print('Объем оперативной памяти потребляемый функцией-генератором списка, Мб:', gen_list(1000000)) #вызов функции с декоратором